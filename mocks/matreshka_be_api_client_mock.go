package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_matreshka_api "github.com/godverv/matreshka-be/pkg/api/matreshka_api"
	"github.com/gojuno/minimock/v3"
	grpc "google.golang.org/grpc"
)

// MatreshkaBeAPIClientMock implements matreshka_api.MatreshkaBeAPIClient
type MatreshkaBeAPIClientMock struct {
	t minimock.Tester

	funcApiVersion          func(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption) (ap1 *mm_matreshka_api.ApiVersion_Response, err error)
	inspectFuncApiVersion   func(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption)
	afterApiVersionCounter  uint64
	beforeApiVersionCounter uint64
	ApiVersionMock          mMatreshkaBeAPIClientMockApiVersion

	funcCreateServiceConfig          func(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption) (cp1 *mm_matreshka_api.CreateServiceConfig_Response, err error)
	inspectFuncCreateServiceConfig   func(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption)
	afterCreateServiceConfigCounter  uint64
	beforeCreateServiceConfigCounter uint64
	CreateServiceConfigMock          mMatreshkaBeAPIClientMockCreateServiceConfig

	funcGetConfig          func(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfig_Response, err error)
	inspectFuncGetConfig   func(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption)
	afterGetConfigCounter  uint64
	beforeGetConfigCounter uint64
	GetConfigMock          mMatreshkaBeAPIClientMockGetConfig

	funcGetConfigRaw          func(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfigRaw_Response, err error)
	inspectFuncGetConfigRaw   func(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption)
	afterGetConfigRawCounter  uint64
	beforeGetConfigRawCounter uint64
	GetConfigRawMock          mMatreshkaBeAPIClientMockGetConfigRaw

	funcPatchConfigEnv          func(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption) (pp1 *mm_matreshka_api.PatchConfigEnv_Response, err error)
	inspectFuncPatchConfigEnv   func(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption)
	afterPatchConfigEnvCounter  uint64
	beforePatchConfigEnvCounter uint64
	PatchConfigEnvMock          mMatreshkaBeAPIClientMockPatchConfigEnv
}

// NewMatreshkaBeAPIClientMock returns a mock for matreshka_api.MatreshkaBeAPIClient
func NewMatreshkaBeAPIClientMock(t minimock.Tester) *MatreshkaBeAPIClientMock {
	m := &MatreshkaBeAPIClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApiVersionMock = mMatreshkaBeAPIClientMockApiVersion{mock: m}
	m.ApiVersionMock.callArgs = []*MatreshkaBeAPIClientMockApiVersionParams{}

	m.CreateServiceConfigMock = mMatreshkaBeAPIClientMockCreateServiceConfig{mock: m}
	m.CreateServiceConfigMock.callArgs = []*MatreshkaBeAPIClientMockCreateServiceConfigParams{}

	m.GetConfigMock = mMatreshkaBeAPIClientMockGetConfig{mock: m}
	m.GetConfigMock.callArgs = []*MatreshkaBeAPIClientMockGetConfigParams{}

	m.GetConfigRawMock = mMatreshkaBeAPIClientMockGetConfigRaw{mock: m}
	m.GetConfigRawMock.callArgs = []*MatreshkaBeAPIClientMockGetConfigRawParams{}

	m.PatchConfigEnvMock = mMatreshkaBeAPIClientMockPatchConfigEnv{mock: m}
	m.PatchConfigEnvMock.callArgs = []*MatreshkaBeAPIClientMockPatchConfigEnvParams{}

	return m
}

type mMatreshkaBeAPIClientMockApiVersion struct {
	mock               *MatreshkaBeAPIClientMock
	defaultExpectation *MatreshkaBeAPIClientMockApiVersionExpectation
	expectations       []*MatreshkaBeAPIClientMockApiVersionExpectation

	callArgs []*MatreshkaBeAPIClientMockApiVersionParams
	mutex    sync.RWMutex
}

// MatreshkaBeAPIClientMockApiVersionExpectation specifies expectation struct of the MatreshkaBeAPIClient.ApiVersion
type MatreshkaBeAPIClientMockApiVersionExpectation struct {
	mock    *MatreshkaBeAPIClientMock
	params  *MatreshkaBeAPIClientMockApiVersionParams
	results *MatreshkaBeAPIClientMockApiVersionResults
	Counter uint64
}

// MatreshkaBeAPIClientMockApiVersionParams contains parameters of the MatreshkaBeAPIClient.ApiVersion
type MatreshkaBeAPIClientMockApiVersionParams struct {
	ctx  context.Context
	in   *mm_matreshka_api.ApiVersion_Request
	opts []grpc.CallOption
}

// MatreshkaBeAPIClientMockApiVersionResults contains results of the MatreshkaBeAPIClient.ApiVersion
type MatreshkaBeAPIClientMockApiVersionResults struct {
	ap1 *mm_matreshka_api.ApiVersion_Response
	err error
}

// Expect sets up expected params for MatreshkaBeAPIClient.ApiVersion
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) Expect(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption) *mMatreshkaBeAPIClientMockApiVersion {
	if mmApiVersion.mock.funcApiVersion != nil {
		mmApiVersion.mock.t.Fatalf("MatreshkaBeAPIClientMock.ApiVersion mock is already set by Set")
	}

	if mmApiVersion.defaultExpectation == nil {
		mmApiVersion.defaultExpectation = &MatreshkaBeAPIClientMockApiVersionExpectation{}
	}

	mmApiVersion.defaultExpectation.params = &MatreshkaBeAPIClientMockApiVersionParams{ctx, in, opts}
	for _, e := range mmApiVersion.expectations {
		if minimock.Equal(e.params, mmApiVersion.defaultExpectation.params) {
			mmApiVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApiVersion.defaultExpectation.params)
		}
	}

	return mmApiVersion
}

// Inspect accepts an inspector function that has same arguments as the MatreshkaBeAPIClient.ApiVersion
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) Inspect(f func(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption)) *mMatreshkaBeAPIClientMockApiVersion {
	if mmApiVersion.mock.inspectFuncApiVersion != nil {
		mmApiVersion.mock.t.Fatalf("Inspect function is already set for MatreshkaBeAPIClientMock.ApiVersion")
	}

	mmApiVersion.mock.inspectFuncApiVersion = f

	return mmApiVersion
}

// Return sets up results that will be returned by MatreshkaBeAPIClient.ApiVersion
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) Return(ap1 *mm_matreshka_api.ApiVersion_Response, err error) *MatreshkaBeAPIClientMock {
	if mmApiVersion.mock.funcApiVersion != nil {
		mmApiVersion.mock.t.Fatalf("MatreshkaBeAPIClientMock.ApiVersion mock is already set by Set")
	}

	if mmApiVersion.defaultExpectation == nil {
		mmApiVersion.defaultExpectation = &MatreshkaBeAPIClientMockApiVersionExpectation{mock: mmApiVersion.mock}
	}
	mmApiVersion.defaultExpectation.results = &MatreshkaBeAPIClientMockApiVersionResults{ap1, err}
	return mmApiVersion.mock
}

// Set uses given function f to mock the MatreshkaBeAPIClient.ApiVersion method
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) Set(f func(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption) (ap1 *mm_matreshka_api.ApiVersion_Response, err error)) *MatreshkaBeAPIClientMock {
	if mmApiVersion.defaultExpectation != nil {
		mmApiVersion.mock.t.Fatalf("Default expectation is already set for the MatreshkaBeAPIClient.ApiVersion method")
	}

	if len(mmApiVersion.expectations) > 0 {
		mmApiVersion.mock.t.Fatalf("Some expectations are already set for the MatreshkaBeAPIClient.ApiVersion method")
	}

	mmApiVersion.mock.funcApiVersion = f
	return mmApiVersion.mock
}

// When sets expectation for the MatreshkaBeAPIClient.ApiVersion which will trigger the result defined by the following
// Then helper
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) When(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption) *MatreshkaBeAPIClientMockApiVersionExpectation {
	if mmApiVersion.mock.funcApiVersion != nil {
		mmApiVersion.mock.t.Fatalf("MatreshkaBeAPIClientMock.ApiVersion mock is already set by Set")
	}

	expectation := &MatreshkaBeAPIClientMockApiVersionExpectation{
		mock:   mmApiVersion.mock,
		params: &MatreshkaBeAPIClientMockApiVersionParams{ctx, in, opts},
	}
	mmApiVersion.expectations = append(mmApiVersion.expectations, expectation)
	return expectation
}

// Then sets up MatreshkaBeAPIClient.ApiVersion return parameters for the expectation previously defined by the When method
func (e *MatreshkaBeAPIClientMockApiVersionExpectation) Then(ap1 *mm_matreshka_api.ApiVersion_Response, err error) *MatreshkaBeAPIClientMock {
	e.results = &MatreshkaBeAPIClientMockApiVersionResults{ap1, err}
	return e.mock
}

// ApiVersion implements matreshka_api.MatreshkaBeAPIClient
func (mmApiVersion *MatreshkaBeAPIClientMock) ApiVersion(ctx context.Context, in *mm_matreshka_api.ApiVersion_Request, opts ...grpc.CallOption) (ap1 *mm_matreshka_api.ApiVersion_Response, err error) {
	mm_atomic.AddUint64(&mmApiVersion.beforeApiVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmApiVersion.afterApiVersionCounter, 1)

	if mmApiVersion.inspectFuncApiVersion != nil {
		mmApiVersion.inspectFuncApiVersion(ctx, in, opts...)
	}

	mm_params := &MatreshkaBeAPIClientMockApiVersionParams{ctx, in, opts}

	// Record call args
	mmApiVersion.ApiVersionMock.mutex.Lock()
	mmApiVersion.ApiVersionMock.callArgs = append(mmApiVersion.ApiVersionMock.callArgs, mm_params)
	mmApiVersion.ApiVersionMock.mutex.Unlock()

	for _, e := range mmApiVersion.ApiVersionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmApiVersion.ApiVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApiVersion.ApiVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmApiVersion.ApiVersionMock.defaultExpectation.params
		mm_got := MatreshkaBeAPIClientMockApiVersionParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApiVersion.t.Errorf("MatreshkaBeAPIClientMock.ApiVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApiVersion.ApiVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmApiVersion.t.Fatal("No results are set for the MatreshkaBeAPIClientMock.ApiVersion")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmApiVersion.funcApiVersion != nil {
		return mmApiVersion.funcApiVersion(ctx, in, opts...)
	}
	mmApiVersion.t.Fatalf("Unexpected call to MatreshkaBeAPIClientMock.ApiVersion. %v %v %v", ctx, in, opts)
	return
}

// ApiVersionAfterCounter returns a count of finished MatreshkaBeAPIClientMock.ApiVersion invocations
func (mmApiVersion *MatreshkaBeAPIClientMock) ApiVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApiVersion.afterApiVersionCounter)
}

// ApiVersionBeforeCounter returns a count of MatreshkaBeAPIClientMock.ApiVersion invocations
func (mmApiVersion *MatreshkaBeAPIClientMock) ApiVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApiVersion.beforeApiVersionCounter)
}

// Calls returns a list of arguments used in each call to MatreshkaBeAPIClientMock.ApiVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApiVersion *mMatreshkaBeAPIClientMockApiVersion) Calls() []*MatreshkaBeAPIClientMockApiVersionParams {
	mmApiVersion.mutex.RLock()

	argCopy := make([]*MatreshkaBeAPIClientMockApiVersionParams, len(mmApiVersion.callArgs))
	copy(argCopy, mmApiVersion.callArgs)

	mmApiVersion.mutex.RUnlock()

	return argCopy
}

// MinimockApiVersionDone returns true if the count of the ApiVersion invocations corresponds
// the number of defined expectations
func (m *MatreshkaBeAPIClientMock) MinimockApiVersionDone() bool {
	for _, e := range m.ApiVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApiVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApiVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApiVersion != nil && mm_atomic.LoadUint64(&m.afterApiVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockApiVersionInspect logs each unmet expectation
func (m *MatreshkaBeAPIClientMock) MinimockApiVersionInspect() {
	for _, e := range m.ApiVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.ApiVersion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApiVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApiVersionCounter) < 1 {
		if m.ApiVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatreshkaBeAPIClientMock.ApiVersion")
		} else {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.ApiVersion with params: %#v", *m.ApiVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApiVersion != nil && mm_atomic.LoadUint64(&m.afterApiVersionCounter) < 1 {
		m.t.Error("Expected call to MatreshkaBeAPIClientMock.ApiVersion")
	}
}

type mMatreshkaBeAPIClientMockCreateServiceConfig struct {
	mock               *MatreshkaBeAPIClientMock
	defaultExpectation *MatreshkaBeAPIClientMockCreateServiceConfigExpectation
	expectations       []*MatreshkaBeAPIClientMockCreateServiceConfigExpectation

	callArgs []*MatreshkaBeAPIClientMockCreateServiceConfigParams
	mutex    sync.RWMutex
}

// MatreshkaBeAPIClientMockCreateServiceConfigExpectation specifies expectation struct of the MatreshkaBeAPIClient.CreateServiceConfig
type MatreshkaBeAPIClientMockCreateServiceConfigExpectation struct {
	mock    *MatreshkaBeAPIClientMock
	params  *MatreshkaBeAPIClientMockCreateServiceConfigParams
	results *MatreshkaBeAPIClientMockCreateServiceConfigResults
	Counter uint64
}

// MatreshkaBeAPIClientMockCreateServiceConfigParams contains parameters of the MatreshkaBeAPIClient.CreateServiceConfig
type MatreshkaBeAPIClientMockCreateServiceConfigParams struct {
	ctx  context.Context
	in   *mm_matreshka_api.CreateServiceConfig_Request
	opts []grpc.CallOption
}

// MatreshkaBeAPIClientMockCreateServiceConfigResults contains results of the MatreshkaBeAPIClient.CreateServiceConfig
type MatreshkaBeAPIClientMockCreateServiceConfigResults struct {
	cp1 *mm_matreshka_api.CreateServiceConfig_Response
	err error
}

// Expect sets up expected params for MatreshkaBeAPIClient.CreateServiceConfig
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) Expect(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption) *mMatreshkaBeAPIClientMockCreateServiceConfig {
	if mmCreateServiceConfig.mock.funcCreateServiceConfig != nil {
		mmCreateServiceConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.CreateServiceConfig mock is already set by Set")
	}

	if mmCreateServiceConfig.defaultExpectation == nil {
		mmCreateServiceConfig.defaultExpectation = &MatreshkaBeAPIClientMockCreateServiceConfigExpectation{}
	}

	mmCreateServiceConfig.defaultExpectation.params = &MatreshkaBeAPIClientMockCreateServiceConfigParams{ctx, in, opts}
	for _, e := range mmCreateServiceConfig.expectations {
		if minimock.Equal(e.params, mmCreateServiceConfig.defaultExpectation.params) {
			mmCreateServiceConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateServiceConfig.defaultExpectation.params)
		}
	}

	return mmCreateServiceConfig
}

// Inspect accepts an inspector function that has same arguments as the MatreshkaBeAPIClient.CreateServiceConfig
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) Inspect(f func(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption)) *mMatreshkaBeAPIClientMockCreateServiceConfig {
	if mmCreateServiceConfig.mock.inspectFuncCreateServiceConfig != nil {
		mmCreateServiceConfig.mock.t.Fatalf("Inspect function is already set for MatreshkaBeAPIClientMock.CreateServiceConfig")
	}

	mmCreateServiceConfig.mock.inspectFuncCreateServiceConfig = f

	return mmCreateServiceConfig
}

// Return sets up results that will be returned by MatreshkaBeAPIClient.CreateServiceConfig
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) Return(cp1 *mm_matreshka_api.CreateServiceConfig_Response, err error) *MatreshkaBeAPIClientMock {
	if mmCreateServiceConfig.mock.funcCreateServiceConfig != nil {
		mmCreateServiceConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.CreateServiceConfig mock is already set by Set")
	}

	if mmCreateServiceConfig.defaultExpectation == nil {
		mmCreateServiceConfig.defaultExpectation = &MatreshkaBeAPIClientMockCreateServiceConfigExpectation{mock: mmCreateServiceConfig.mock}
	}
	mmCreateServiceConfig.defaultExpectation.results = &MatreshkaBeAPIClientMockCreateServiceConfigResults{cp1, err}
	return mmCreateServiceConfig.mock
}

// Set uses given function f to mock the MatreshkaBeAPIClient.CreateServiceConfig method
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) Set(f func(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption) (cp1 *mm_matreshka_api.CreateServiceConfig_Response, err error)) *MatreshkaBeAPIClientMock {
	if mmCreateServiceConfig.defaultExpectation != nil {
		mmCreateServiceConfig.mock.t.Fatalf("Default expectation is already set for the MatreshkaBeAPIClient.CreateServiceConfig method")
	}

	if len(mmCreateServiceConfig.expectations) > 0 {
		mmCreateServiceConfig.mock.t.Fatalf("Some expectations are already set for the MatreshkaBeAPIClient.CreateServiceConfig method")
	}

	mmCreateServiceConfig.mock.funcCreateServiceConfig = f
	return mmCreateServiceConfig.mock
}

// When sets expectation for the MatreshkaBeAPIClient.CreateServiceConfig which will trigger the result defined by the following
// Then helper
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) When(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption) *MatreshkaBeAPIClientMockCreateServiceConfigExpectation {
	if mmCreateServiceConfig.mock.funcCreateServiceConfig != nil {
		mmCreateServiceConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.CreateServiceConfig mock is already set by Set")
	}

	expectation := &MatreshkaBeAPIClientMockCreateServiceConfigExpectation{
		mock:   mmCreateServiceConfig.mock,
		params: &MatreshkaBeAPIClientMockCreateServiceConfigParams{ctx, in, opts},
	}
	mmCreateServiceConfig.expectations = append(mmCreateServiceConfig.expectations, expectation)
	return expectation
}

// Then sets up MatreshkaBeAPIClient.CreateServiceConfig return parameters for the expectation previously defined by the When method
func (e *MatreshkaBeAPIClientMockCreateServiceConfigExpectation) Then(cp1 *mm_matreshka_api.CreateServiceConfig_Response, err error) *MatreshkaBeAPIClientMock {
	e.results = &MatreshkaBeAPIClientMockCreateServiceConfigResults{cp1, err}
	return e.mock
}

// CreateServiceConfig implements matreshka_api.MatreshkaBeAPIClient
func (mmCreateServiceConfig *MatreshkaBeAPIClientMock) CreateServiceConfig(ctx context.Context, in *mm_matreshka_api.CreateServiceConfig_Request, opts ...grpc.CallOption) (cp1 *mm_matreshka_api.CreateServiceConfig_Response, err error) {
	mm_atomic.AddUint64(&mmCreateServiceConfig.beforeCreateServiceConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateServiceConfig.afterCreateServiceConfigCounter, 1)

	if mmCreateServiceConfig.inspectFuncCreateServiceConfig != nil {
		mmCreateServiceConfig.inspectFuncCreateServiceConfig(ctx, in, opts...)
	}

	mm_params := &MatreshkaBeAPIClientMockCreateServiceConfigParams{ctx, in, opts}

	// Record call args
	mmCreateServiceConfig.CreateServiceConfigMock.mutex.Lock()
	mmCreateServiceConfig.CreateServiceConfigMock.callArgs = append(mmCreateServiceConfig.CreateServiceConfigMock.callArgs, mm_params)
	mmCreateServiceConfig.CreateServiceConfigMock.mutex.Unlock()

	for _, e := range mmCreateServiceConfig.CreateServiceConfigMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateServiceConfig.CreateServiceConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateServiceConfig.CreateServiceConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateServiceConfig.CreateServiceConfigMock.defaultExpectation.params
		mm_got := MatreshkaBeAPIClientMockCreateServiceConfigParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateServiceConfig.t.Errorf("MatreshkaBeAPIClientMock.CreateServiceConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateServiceConfig.CreateServiceConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateServiceConfig.t.Fatal("No results are set for the MatreshkaBeAPIClientMock.CreateServiceConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateServiceConfig.funcCreateServiceConfig != nil {
		return mmCreateServiceConfig.funcCreateServiceConfig(ctx, in, opts...)
	}
	mmCreateServiceConfig.t.Fatalf("Unexpected call to MatreshkaBeAPIClientMock.CreateServiceConfig. %v %v %v", ctx, in, opts)
	return
}

// CreateServiceConfigAfterCounter returns a count of finished MatreshkaBeAPIClientMock.CreateServiceConfig invocations
func (mmCreateServiceConfig *MatreshkaBeAPIClientMock) CreateServiceConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateServiceConfig.afterCreateServiceConfigCounter)
}

// CreateServiceConfigBeforeCounter returns a count of MatreshkaBeAPIClientMock.CreateServiceConfig invocations
func (mmCreateServiceConfig *MatreshkaBeAPIClientMock) CreateServiceConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateServiceConfig.beforeCreateServiceConfigCounter)
}

// Calls returns a list of arguments used in each call to MatreshkaBeAPIClientMock.CreateServiceConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateServiceConfig *mMatreshkaBeAPIClientMockCreateServiceConfig) Calls() []*MatreshkaBeAPIClientMockCreateServiceConfigParams {
	mmCreateServiceConfig.mutex.RLock()

	argCopy := make([]*MatreshkaBeAPIClientMockCreateServiceConfigParams, len(mmCreateServiceConfig.callArgs))
	copy(argCopy, mmCreateServiceConfig.callArgs)

	mmCreateServiceConfig.mutex.RUnlock()

	return argCopy
}

// MinimockCreateServiceConfigDone returns true if the count of the CreateServiceConfig invocations corresponds
// the number of defined expectations
func (m *MatreshkaBeAPIClientMock) MinimockCreateServiceConfigDone() bool {
	for _, e := range m.CreateServiceConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateServiceConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateServiceConfig != nil && mm_atomic.LoadUint64(&m.afterCreateServiceConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateServiceConfigInspect logs each unmet expectation
func (m *MatreshkaBeAPIClientMock) MinimockCreateServiceConfigInspect() {
	for _, e := range m.CreateServiceConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.CreateServiceConfig with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateServiceConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateServiceConfigCounter) < 1 {
		if m.CreateServiceConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatreshkaBeAPIClientMock.CreateServiceConfig")
		} else {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.CreateServiceConfig with params: %#v", *m.CreateServiceConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateServiceConfig != nil && mm_atomic.LoadUint64(&m.afterCreateServiceConfigCounter) < 1 {
		m.t.Error("Expected call to MatreshkaBeAPIClientMock.CreateServiceConfig")
	}
}

type mMatreshkaBeAPIClientMockGetConfig struct {
	mock               *MatreshkaBeAPIClientMock
	defaultExpectation *MatreshkaBeAPIClientMockGetConfigExpectation
	expectations       []*MatreshkaBeAPIClientMockGetConfigExpectation

	callArgs []*MatreshkaBeAPIClientMockGetConfigParams
	mutex    sync.RWMutex
}

// MatreshkaBeAPIClientMockGetConfigExpectation specifies expectation struct of the MatreshkaBeAPIClient.GetConfig
type MatreshkaBeAPIClientMockGetConfigExpectation struct {
	mock    *MatreshkaBeAPIClientMock
	params  *MatreshkaBeAPIClientMockGetConfigParams
	results *MatreshkaBeAPIClientMockGetConfigResults
	Counter uint64
}

// MatreshkaBeAPIClientMockGetConfigParams contains parameters of the MatreshkaBeAPIClient.GetConfig
type MatreshkaBeAPIClientMockGetConfigParams struct {
	ctx  context.Context
	in   *mm_matreshka_api.GetConfig_Request
	opts []grpc.CallOption
}

// MatreshkaBeAPIClientMockGetConfigResults contains results of the MatreshkaBeAPIClient.GetConfig
type MatreshkaBeAPIClientMockGetConfigResults struct {
	gp1 *mm_matreshka_api.GetConfig_Response
	err error
}

// Expect sets up expected params for MatreshkaBeAPIClient.GetConfig
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) Expect(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption) *mMatreshkaBeAPIClientMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &MatreshkaBeAPIClientMockGetConfigExpectation{}
	}

	mmGetConfig.defaultExpectation.params = &MatreshkaBeAPIClientMockGetConfigParams{ctx, in, opts}
	for _, e := range mmGetConfig.expectations {
		if minimock.Equal(e.params, mmGetConfig.defaultExpectation.params) {
			mmGetConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConfig.defaultExpectation.params)
		}
	}

	return mmGetConfig
}

// Inspect accepts an inspector function that has same arguments as the MatreshkaBeAPIClient.GetConfig
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) Inspect(f func(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption)) *mMatreshkaBeAPIClientMockGetConfig {
	if mmGetConfig.mock.inspectFuncGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("Inspect function is already set for MatreshkaBeAPIClientMock.GetConfig")
	}

	mmGetConfig.mock.inspectFuncGetConfig = f

	return mmGetConfig
}

// Return sets up results that will be returned by MatreshkaBeAPIClient.GetConfig
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) Return(gp1 *mm_matreshka_api.GetConfig_Response, err error) *MatreshkaBeAPIClientMock {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &MatreshkaBeAPIClientMockGetConfigExpectation{mock: mmGetConfig.mock}
	}
	mmGetConfig.defaultExpectation.results = &MatreshkaBeAPIClientMockGetConfigResults{gp1, err}
	return mmGetConfig.mock
}

// Set uses given function f to mock the MatreshkaBeAPIClient.GetConfig method
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) Set(f func(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfig_Response, err error)) *MatreshkaBeAPIClientMock {
	if mmGetConfig.defaultExpectation != nil {
		mmGetConfig.mock.t.Fatalf("Default expectation is already set for the MatreshkaBeAPIClient.GetConfig method")
	}

	if len(mmGetConfig.expectations) > 0 {
		mmGetConfig.mock.t.Fatalf("Some expectations are already set for the MatreshkaBeAPIClient.GetConfig method")
	}

	mmGetConfig.mock.funcGetConfig = f
	return mmGetConfig.mock
}

// When sets expectation for the MatreshkaBeAPIClient.GetConfig which will trigger the result defined by the following
// Then helper
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) When(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption) *MatreshkaBeAPIClientMockGetConfigExpectation {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfig mock is already set by Set")
	}

	expectation := &MatreshkaBeAPIClientMockGetConfigExpectation{
		mock:   mmGetConfig.mock,
		params: &MatreshkaBeAPIClientMockGetConfigParams{ctx, in, opts},
	}
	mmGetConfig.expectations = append(mmGetConfig.expectations, expectation)
	return expectation
}

// Then sets up MatreshkaBeAPIClient.GetConfig return parameters for the expectation previously defined by the When method
func (e *MatreshkaBeAPIClientMockGetConfigExpectation) Then(gp1 *mm_matreshka_api.GetConfig_Response, err error) *MatreshkaBeAPIClientMock {
	e.results = &MatreshkaBeAPIClientMockGetConfigResults{gp1, err}
	return e.mock
}

// GetConfig implements matreshka_api.MatreshkaBeAPIClient
func (mmGetConfig *MatreshkaBeAPIClientMock) GetConfig(ctx context.Context, in *mm_matreshka_api.GetConfig_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfig_Response, err error) {
	mm_atomic.AddUint64(&mmGetConfig.beforeGetConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfig.afterGetConfigCounter, 1)

	if mmGetConfig.inspectFuncGetConfig != nil {
		mmGetConfig.inspectFuncGetConfig(ctx, in, opts...)
	}

	mm_params := &MatreshkaBeAPIClientMockGetConfigParams{ctx, in, opts}

	// Record call args
	mmGetConfig.GetConfigMock.mutex.Lock()
	mmGetConfig.GetConfigMock.callArgs = append(mmGetConfig.GetConfigMock.callArgs, mm_params)
	mmGetConfig.GetConfigMock.mutex.Unlock()

	for _, e := range mmGetConfig.GetConfigMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetConfig.GetConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfig.GetConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConfig.GetConfigMock.defaultExpectation.params
		mm_got := MatreshkaBeAPIClientMockGetConfigParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConfig.t.Errorf("MatreshkaBeAPIClientMock.GetConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConfig.GetConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfig.t.Fatal("No results are set for the MatreshkaBeAPIClientMock.GetConfig")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetConfig.funcGetConfig != nil {
		return mmGetConfig.funcGetConfig(ctx, in, opts...)
	}
	mmGetConfig.t.Fatalf("Unexpected call to MatreshkaBeAPIClientMock.GetConfig. %v %v %v", ctx, in, opts)
	return
}

// GetConfigAfterCounter returns a count of finished MatreshkaBeAPIClientMock.GetConfig invocations
func (mmGetConfig *MatreshkaBeAPIClientMock) GetConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.afterGetConfigCounter)
}

// GetConfigBeforeCounter returns a count of MatreshkaBeAPIClientMock.GetConfig invocations
func (mmGetConfig *MatreshkaBeAPIClientMock) GetConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.beforeGetConfigCounter)
}

// Calls returns a list of arguments used in each call to MatreshkaBeAPIClientMock.GetConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConfig *mMatreshkaBeAPIClientMockGetConfig) Calls() []*MatreshkaBeAPIClientMockGetConfigParams {
	mmGetConfig.mutex.RLock()

	argCopy := make([]*MatreshkaBeAPIClientMockGetConfigParams, len(mmGetConfig.callArgs))
	copy(argCopy, mmGetConfig.callArgs)

	mmGetConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetConfigDone returns true if the count of the GetConfig invocations corresponds
// the number of defined expectations
func (m *MatreshkaBeAPIClientMock) MinimockGetConfigDone() bool {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetConfigInspect logs each unmet expectation
func (m *MatreshkaBeAPIClientMock) MinimockGetConfigInspect() {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.GetConfig with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		if m.GetConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatreshkaBeAPIClientMock.GetConfig")
		} else {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.GetConfig with params: %#v", *m.GetConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		m.t.Error("Expected call to MatreshkaBeAPIClientMock.GetConfig")
	}
}

type mMatreshkaBeAPIClientMockGetConfigRaw struct {
	mock               *MatreshkaBeAPIClientMock
	defaultExpectation *MatreshkaBeAPIClientMockGetConfigRawExpectation
	expectations       []*MatreshkaBeAPIClientMockGetConfigRawExpectation

	callArgs []*MatreshkaBeAPIClientMockGetConfigRawParams
	mutex    sync.RWMutex
}

// MatreshkaBeAPIClientMockGetConfigRawExpectation specifies expectation struct of the MatreshkaBeAPIClient.GetConfigRaw
type MatreshkaBeAPIClientMockGetConfigRawExpectation struct {
	mock    *MatreshkaBeAPIClientMock
	params  *MatreshkaBeAPIClientMockGetConfigRawParams
	results *MatreshkaBeAPIClientMockGetConfigRawResults
	Counter uint64
}

// MatreshkaBeAPIClientMockGetConfigRawParams contains parameters of the MatreshkaBeAPIClient.GetConfigRaw
type MatreshkaBeAPIClientMockGetConfigRawParams struct {
	ctx  context.Context
	in   *mm_matreshka_api.GetConfigRaw_Request
	opts []grpc.CallOption
}

// MatreshkaBeAPIClientMockGetConfigRawResults contains results of the MatreshkaBeAPIClient.GetConfigRaw
type MatreshkaBeAPIClientMockGetConfigRawResults struct {
	gp1 *mm_matreshka_api.GetConfigRaw_Response
	err error
}

// Expect sets up expected params for MatreshkaBeAPIClient.GetConfigRaw
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) Expect(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption) *mMatreshkaBeAPIClientMockGetConfigRaw {
	if mmGetConfigRaw.mock.funcGetConfigRaw != nil {
		mmGetConfigRaw.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfigRaw mock is already set by Set")
	}

	if mmGetConfigRaw.defaultExpectation == nil {
		mmGetConfigRaw.defaultExpectation = &MatreshkaBeAPIClientMockGetConfigRawExpectation{}
	}

	mmGetConfigRaw.defaultExpectation.params = &MatreshkaBeAPIClientMockGetConfigRawParams{ctx, in, opts}
	for _, e := range mmGetConfigRaw.expectations {
		if minimock.Equal(e.params, mmGetConfigRaw.defaultExpectation.params) {
			mmGetConfigRaw.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConfigRaw.defaultExpectation.params)
		}
	}

	return mmGetConfigRaw
}

// Inspect accepts an inspector function that has same arguments as the MatreshkaBeAPIClient.GetConfigRaw
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) Inspect(f func(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption)) *mMatreshkaBeAPIClientMockGetConfigRaw {
	if mmGetConfigRaw.mock.inspectFuncGetConfigRaw != nil {
		mmGetConfigRaw.mock.t.Fatalf("Inspect function is already set for MatreshkaBeAPIClientMock.GetConfigRaw")
	}

	mmGetConfigRaw.mock.inspectFuncGetConfigRaw = f

	return mmGetConfigRaw
}

// Return sets up results that will be returned by MatreshkaBeAPIClient.GetConfigRaw
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) Return(gp1 *mm_matreshka_api.GetConfigRaw_Response, err error) *MatreshkaBeAPIClientMock {
	if mmGetConfigRaw.mock.funcGetConfigRaw != nil {
		mmGetConfigRaw.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfigRaw mock is already set by Set")
	}

	if mmGetConfigRaw.defaultExpectation == nil {
		mmGetConfigRaw.defaultExpectation = &MatreshkaBeAPIClientMockGetConfigRawExpectation{mock: mmGetConfigRaw.mock}
	}
	mmGetConfigRaw.defaultExpectation.results = &MatreshkaBeAPIClientMockGetConfigRawResults{gp1, err}
	return mmGetConfigRaw.mock
}

// Set uses given function f to mock the MatreshkaBeAPIClient.GetConfigRaw method
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) Set(f func(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfigRaw_Response, err error)) *MatreshkaBeAPIClientMock {
	if mmGetConfigRaw.defaultExpectation != nil {
		mmGetConfigRaw.mock.t.Fatalf("Default expectation is already set for the MatreshkaBeAPIClient.GetConfigRaw method")
	}

	if len(mmGetConfigRaw.expectations) > 0 {
		mmGetConfigRaw.mock.t.Fatalf("Some expectations are already set for the MatreshkaBeAPIClient.GetConfigRaw method")
	}

	mmGetConfigRaw.mock.funcGetConfigRaw = f
	return mmGetConfigRaw.mock
}

// When sets expectation for the MatreshkaBeAPIClient.GetConfigRaw which will trigger the result defined by the following
// Then helper
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) When(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption) *MatreshkaBeAPIClientMockGetConfigRawExpectation {
	if mmGetConfigRaw.mock.funcGetConfigRaw != nil {
		mmGetConfigRaw.mock.t.Fatalf("MatreshkaBeAPIClientMock.GetConfigRaw mock is already set by Set")
	}

	expectation := &MatreshkaBeAPIClientMockGetConfigRawExpectation{
		mock:   mmGetConfigRaw.mock,
		params: &MatreshkaBeAPIClientMockGetConfigRawParams{ctx, in, opts},
	}
	mmGetConfigRaw.expectations = append(mmGetConfigRaw.expectations, expectation)
	return expectation
}

// Then sets up MatreshkaBeAPIClient.GetConfigRaw return parameters for the expectation previously defined by the When method
func (e *MatreshkaBeAPIClientMockGetConfigRawExpectation) Then(gp1 *mm_matreshka_api.GetConfigRaw_Response, err error) *MatreshkaBeAPIClientMock {
	e.results = &MatreshkaBeAPIClientMockGetConfigRawResults{gp1, err}
	return e.mock
}

// GetConfigRaw implements matreshka_api.MatreshkaBeAPIClient
func (mmGetConfigRaw *MatreshkaBeAPIClientMock) GetConfigRaw(ctx context.Context, in *mm_matreshka_api.GetConfigRaw_Request, opts ...grpc.CallOption) (gp1 *mm_matreshka_api.GetConfigRaw_Response, err error) {
	mm_atomic.AddUint64(&mmGetConfigRaw.beforeGetConfigRawCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfigRaw.afterGetConfigRawCounter, 1)

	if mmGetConfigRaw.inspectFuncGetConfigRaw != nil {
		mmGetConfigRaw.inspectFuncGetConfigRaw(ctx, in, opts...)
	}

	mm_params := &MatreshkaBeAPIClientMockGetConfigRawParams{ctx, in, opts}

	// Record call args
	mmGetConfigRaw.GetConfigRawMock.mutex.Lock()
	mmGetConfigRaw.GetConfigRawMock.callArgs = append(mmGetConfigRaw.GetConfigRawMock.callArgs, mm_params)
	mmGetConfigRaw.GetConfigRawMock.mutex.Unlock()

	for _, e := range mmGetConfigRaw.GetConfigRawMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetConfigRaw.GetConfigRawMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfigRaw.GetConfigRawMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConfigRaw.GetConfigRawMock.defaultExpectation.params
		mm_got := MatreshkaBeAPIClientMockGetConfigRawParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConfigRaw.t.Errorf("MatreshkaBeAPIClientMock.GetConfigRaw got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConfigRaw.GetConfigRawMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfigRaw.t.Fatal("No results are set for the MatreshkaBeAPIClientMock.GetConfigRaw")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetConfigRaw.funcGetConfigRaw != nil {
		return mmGetConfigRaw.funcGetConfigRaw(ctx, in, opts...)
	}
	mmGetConfigRaw.t.Fatalf("Unexpected call to MatreshkaBeAPIClientMock.GetConfigRaw. %v %v %v", ctx, in, opts)
	return
}

// GetConfigRawAfterCounter returns a count of finished MatreshkaBeAPIClientMock.GetConfigRaw invocations
func (mmGetConfigRaw *MatreshkaBeAPIClientMock) GetConfigRawAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfigRaw.afterGetConfigRawCounter)
}

// GetConfigRawBeforeCounter returns a count of MatreshkaBeAPIClientMock.GetConfigRaw invocations
func (mmGetConfigRaw *MatreshkaBeAPIClientMock) GetConfigRawBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfigRaw.beforeGetConfigRawCounter)
}

// Calls returns a list of arguments used in each call to MatreshkaBeAPIClientMock.GetConfigRaw.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConfigRaw *mMatreshkaBeAPIClientMockGetConfigRaw) Calls() []*MatreshkaBeAPIClientMockGetConfigRawParams {
	mmGetConfigRaw.mutex.RLock()

	argCopy := make([]*MatreshkaBeAPIClientMockGetConfigRawParams, len(mmGetConfigRaw.callArgs))
	copy(argCopy, mmGetConfigRaw.callArgs)

	mmGetConfigRaw.mutex.RUnlock()

	return argCopy
}

// MinimockGetConfigRawDone returns true if the count of the GetConfigRaw invocations corresponds
// the number of defined expectations
func (m *MatreshkaBeAPIClientMock) MinimockGetConfigRawDone() bool {
	for _, e := range m.GetConfigRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigRawMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigRawCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfigRaw != nil && mm_atomic.LoadUint64(&m.afterGetConfigRawCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetConfigRawInspect logs each unmet expectation
func (m *MatreshkaBeAPIClientMock) MinimockGetConfigRawInspect() {
	for _, e := range m.GetConfigRawMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.GetConfigRaw with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigRawMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigRawCounter) < 1 {
		if m.GetConfigRawMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatreshkaBeAPIClientMock.GetConfigRaw")
		} else {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.GetConfigRaw with params: %#v", *m.GetConfigRawMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfigRaw != nil && mm_atomic.LoadUint64(&m.afterGetConfigRawCounter) < 1 {
		m.t.Error("Expected call to MatreshkaBeAPIClientMock.GetConfigRaw")
	}
}

type mMatreshkaBeAPIClientMockPatchConfigEnv struct {
	mock               *MatreshkaBeAPIClientMock
	defaultExpectation *MatreshkaBeAPIClientMockPatchConfigEnvExpectation
	expectations       []*MatreshkaBeAPIClientMockPatchConfigEnvExpectation

	callArgs []*MatreshkaBeAPIClientMockPatchConfigEnvParams
	mutex    sync.RWMutex
}

// MatreshkaBeAPIClientMockPatchConfigEnvExpectation specifies expectation struct of the MatreshkaBeAPIClient.PatchConfigEnv
type MatreshkaBeAPIClientMockPatchConfigEnvExpectation struct {
	mock    *MatreshkaBeAPIClientMock
	params  *MatreshkaBeAPIClientMockPatchConfigEnvParams
	results *MatreshkaBeAPIClientMockPatchConfigEnvResults
	Counter uint64
}

// MatreshkaBeAPIClientMockPatchConfigEnvParams contains parameters of the MatreshkaBeAPIClient.PatchConfigEnv
type MatreshkaBeAPIClientMockPatchConfigEnvParams struct {
	ctx  context.Context
	in   *mm_matreshka_api.PatchConfigEnv_Request
	opts []grpc.CallOption
}

// MatreshkaBeAPIClientMockPatchConfigEnvResults contains results of the MatreshkaBeAPIClient.PatchConfigEnv
type MatreshkaBeAPIClientMockPatchConfigEnvResults struct {
	pp1 *mm_matreshka_api.PatchConfigEnv_Response
	err error
}

// Expect sets up expected params for MatreshkaBeAPIClient.PatchConfigEnv
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) Expect(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption) *mMatreshkaBeAPIClientMockPatchConfigEnv {
	if mmPatchConfigEnv.mock.funcPatchConfigEnv != nil {
		mmPatchConfigEnv.mock.t.Fatalf("MatreshkaBeAPIClientMock.PatchConfigEnv mock is already set by Set")
	}

	if mmPatchConfigEnv.defaultExpectation == nil {
		mmPatchConfigEnv.defaultExpectation = &MatreshkaBeAPIClientMockPatchConfigEnvExpectation{}
	}

	mmPatchConfigEnv.defaultExpectation.params = &MatreshkaBeAPIClientMockPatchConfigEnvParams{ctx, in, opts}
	for _, e := range mmPatchConfigEnv.expectations {
		if minimock.Equal(e.params, mmPatchConfigEnv.defaultExpectation.params) {
			mmPatchConfigEnv.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPatchConfigEnv.defaultExpectation.params)
		}
	}

	return mmPatchConfigEnv
}

// Inspect accepts an inspector function that has same arguments as the MatreshkaBeAPIClient.PatchConfigEnv
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) Inspect(f func(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption)) *mMatreshkaBeAPIClientMockPatchConfigEnv {
	if mmPatchConfigEnv.mock.inspectFuncPatchConfigEnv != nil {
		mmPatchConfigEnv.mock.t.Fatalf("Inspect function is already set for MatreshkaBeAPIClientMock.PatchConfigEnv")
	}

	mmPatchConfigEnv.mock.inspectFuncPatchConfigEnv = f

	return mmPatchConfigEnv
}

// Return sets up results that will be returned by MatreshkaBeAPIClient.PatchConfigEnv
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) Return(pp1 *mm_matreshka_api.PatchConfigEnv_Response, err error) *MatreshkaBeAPIClientMock {
	if mmPatchConfigEnv.mock.funcPatchConfigEnv != nil {
		mmPatchConfigEnv.mock.t.Fatalf("MatreshkaBeAPIClientMock.PatchConfigEnv mock is already set by Set")
	}

	if mmPatchConfigEnv.defaultExpectation == nil {
		mmPatchConfigEnv.defaultExpectation = &MatreshkaBeAPIClientMockPatchConfigEnvExpectation{mock: mmPatchConfigEnv.mock}
	}
	mmPatchConfigEnv.defaultExpectation.results = &MatreshkaBeAPIClientMockPatchConfigEnvResults{pp1, err}
	return mmPatchConfigEnv.mock
}

// Set uses given function f to mock the MatreshkaBeAPIClient.PatchConfigEnv method
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) Set(f func(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption) (pp1 *mm_matreshka_api.PatchConfigEnv_Response, err error)) *MatreshkaBeAPIClientMock {
	if mmPatchConfigEnv.defaultExpectation != nil {
		mmPatchConfigEnv.mock.t.Fatalf("Default expectation is already set for the MatreshkaBeAPIClient.PatchConfigEnv method")
	}

	if len(mmPatchConfigEnv.expectations) > 0 {
		mmPatchConfigEnv.mock.t.Fatalf("Some expectations are already set for the MatreshkaBeAPIClient.PatchConfigEnv method")
	}

	mmPatchConfigEnv.mock.funcPatchConfigEnv = f
	return mmPatchConfigEnv.mock
}

// When sets expectation for the MatreshkaBeAPIClient.PatchConfigEnv which will trigger the result defined by the following
// Then helper
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) When(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption) *MatreshkaBeAPIClientMockPatchConfigEnvExpectation {
	if mmPatchConfigEnv.mock.funcPatchConfigEnv != nil {
		mmPatchConfigEnv.mock.t.Fatalf("MatreshkaBeAPIClientMock.PatchConfigEnv mock is already set by Set")
	}

	expectation := &MatreshkaBeAPIClientMockPatchConfigEnvExpectation{
		mock:   mmPatchConfigEnv.mock,
		params: &MatreshkaBeAPIClientMockPatchConfigEnvParams{ctx, in, opts},
	}
	mmPatchConfigEnv.expectations = append(mmPatchConfigEnv.expectations, expectation)
	return expectation
}

// Then sets up MatreshkaBeAPIClient.PatchConfigEnv return parameters for the expectation previously defined by the When method
func (e *MatreshkaBeAPIClientMockPatchConfigEnvExpectation) Then(pp1 *mm_matreshka_api.PatchConfigEnv_Response, err error) *MatreshkaBeAPIClientMock {
	e.results = &MatreshkaBeAPIClientMockPatchConfigEnvResults{pp1, err}
	return e.mock
}

// PatchConfigEnv implements matreshka_api.MatreshkaBeAPIClient
func (mmPatchConfigEnv *MatreshkaBeAPIClientMock) PatchConfigEnv(ctx context.Context, in *mm_matreshka_api.PatchConfigEnv_Request, opts ...grpc.CallOption) (pp1 *mm_matreshka_api.PatchConfigEnv_Response, err error) {
	mm_atomic.AddUint64(&mmPatchConfigEnv.beforePatchConfigEnvCounter, 1)
	defer mm_atomic.AddUint64(&mmPatchConfigEnv.afterPatchConfigEnvCounter, 1)

	if mmPatchConfigEnv.inspectFuncPatchConfigEnv != nil {
		mmPatchConfigEnv.inspectFuncPatchConfigEnv(ctx, in, opts...)
	}

	mm_params := &MatreshkaBeAPIClientMockPatchConfigEnvParams{ctx, in, opts}

	// Record call args
	mmPatchConfigEnv.PatchConfigEnvMock.mutex.Lock()
	mmPatchConfigEnv.PatchConfigEnvMock.callArgs = append(mmPatchConfigEnv.PatchConfigEnvMock.callArgs, mm_params)
	mmPatchConfigEnv.PatchConfigEnvMock.mutex.Unlock()

	for _, e := range mmPatchConfigEnv.PatchConfigEnvMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmPatchConfigEnv.PatchConfigEnvMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPatchConfigEnv.PatchConfigEnvMock.defaultExpectation.Counter, 1)
		mm_want := mmPatchConfigEnv.PatchConfigEnvMock.defaultExpectation.params
		mm_got := MatreshkaBeAPIClientMockPatchConfigEnvParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPatchConfigEnv.t.Errorf("MatreshkaBeAPIClientMock.PatchConfigEnv got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPatchConfigEnv.PatchConfigEnvMock.defaultExpectation.results
		if mm_results == nil {
			mmPatchConfigEnv.t.Fatal("No results are set for the MatreshkaBeAPIClientMock.PatchConfigEnv")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmPatchConfigEnv.funcPatchConfigEnv != nil {
		return mmPatchConfigEnv.funcPatchConfigEnv(ctx, in, opts...)
	}
	mmPatchConfigEnv.t.Fatalf("Unexpected call to MatreshkaBeAPIClientMock.PatchConfigEnv. %v %v %v", ctx, in, opts)
	return
}

// PatchConfigEnvAfterCounter returns a count of finished MatreshkaBeAPIClientMock.PatchConfigEnv invocations
func (mmPatchConfigEnv *MatreshkaBeAPIClientMock) PatchConfigEnvAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchConfigEnv.afterPatchConfigEnvCounter)
}

// PatchConfigEnvBeforeCounter returns a count of MatreshkaBeAPIClientMock.PatchConfigEnv invocations
func (mmPatchConfigEnv *MatreshkaBeAPIClientMock) PatchConfigEnvBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPatchConfigEnv.beforePatchConfigEnvCounter)
}

// Calls returns a list of arguments used in each call to MatreshkaBeAPIClientMock.PatchConfigEnv.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPatchConfigEnv *mMatreshkaBeAPIClientMockPatchConfigEnv) Calls() []*MatreshkaBeAPIClientMockPatchConfigEnvParams {
	mmPatchConfigEnv.mutex.RLock()

	argCopy := make([]*MatreshkaBeAPIClientMockPatchConfigEnvParams, len(mmPatchConfigEnv.callArgs))
	copy(argCopy, mmPatchConfigEnv.callArgs)

	mmPatchConfigEnv.mutex.RUnlock()

	return argCopy
}

// MinimockPatchConfigEnvDone returns true if the count of the PatchConfigEnv invocations corresponds
// the number of defined expectations
func (m *MatreshkaBeAPIClientMock) MinimockPatchConfigEnvDone() bool {
	for _, e := range m.PatchConfigEnvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PatchConfigEnvMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPatchConfigEnvCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatchConfigEnv != nil && mm_atomic.LoadUint64(&m.afterPatchConfigEnvCounter) < 1 {
		return false
	}
	return true
}

// MinimockPatchConfigEnvInspect logs each unmet expectation
func (m *MatreshkaBeAPIClientMock) MinimockPatchConfigEnvInspect() {
	for _, e := range m.PatchConfigEnvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.PatchConfigEnv with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PatchConfigEnvMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPatchConfigEnvCounter) < 1 {
		if m.PatchConfigEnvMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MatreshkaBeAPIClientMock.PatchConfigEnv")
		} else {
			m.t.Errorf("Expected call to MatreshkaBeAPIClientMock.PatchConfigEnv with params: %#v", *m.PatchConfigEnvMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPatchConfigEnv != nil && mm_atomic.LoadUint64(&m.afterPatchConfigEnvCounter) < 1 {
		m.t.Error("Expected call to MatreshkaBeAPIClientMock.PatchConfigEnv")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MatreshkaBeAPIClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockApiVersionInspect()

		m.MinimockCreateServiceConfigInspect()

		m.MinimockGetConfigInspect()

		m.MinimockGetConfigRawInspect()

		m.MinimockPatchConfigEnvInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MatreshkaBeAPIClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MatreshkaBeAPIClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApiVersionDone() &&
		m.MinimockCreateServiceConfigDone() &&
		m.MinimockGetConfigDone() &&
		m.MinimockGetConfigRawDone() &&
		m.MinimockPatchConfigEnvDone()
}
